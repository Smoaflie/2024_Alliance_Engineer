# 介绍

本仓库为`南京理工大学Alliance战队RM2024复活赛版本工程机器人代码开源资料汇总`

设有五个分支：

> - master 电控代码-下位机

> - hardware-encoder 硬件代码-自定义磁编代码

> - hardware-relay 硬件代码-自定义22路继电器代码

> - custom 电控代码-自定义控制器

> - u3d 算法代码-U3D机械臂正逆解脚本

该分支为`电控代码-下位机`

**简介** 

本开源资料为南京理工大学Alliance战队RM2024复活赛版本工程机器人代码。此机器人的详细设计方案和设计思路见论坛内“RM工程机器人技术开源报告“开源文档。

框架修改自湖大开源：[HNUYueLuRM/basic_framework: framework for developing RoboMaster Electric Control programmes (github.com)](https://github.com/HNUYueLuRM/basic_framework)



**结构分析**

> application/
>
> ├─airpump/								#气泵/气推杆的相关控制代码
>
> │　├─airpump_interface.c		###############
>
> │　├─airpump_interface.h		#为了我方便快速定位”某个应用的某个功能的具体实现“
>
> │　├─airpump.c							#将函数的实现丢到了xxx_interface内，而在xxx.c中进行调用
>
> │　└─airpump.h							#其他几个app层任务也是类似思路，将用...代替
>
> ​															#（纯个人喜好，无任何意义)
>
> ├─arm/											#机械臂的相关控制代码
>
> │　├─...											#xxx_interface及xxx。机械臂控制主逻辑
>
> │　├─auto_mode_.h					#存了自动模式状态机的实现，包括自动模式的格式定义等。
>
> │　├─decode.h							#初版机械臂逆解，已废弃。场上全部由MUC进行解算
>
> │　└─garbage.c							#丢弃的代码，我也不知道为什么还留着（）
>
> ├─chassis/								#底盘控制代码
>
> │　├─...									#xxx_interface及xxx。底盘控制主逻辑
>
> ├─cmd/									#主决策代码，决策结果会下发给其他应用
>
> │　├─flashtask.c/.h						#片上flash的烧写
>
> │　├─...											#xxx_interface及xxx。决策层主逻辑
>
> │　└─vision_rec.h							#图传链路的实现。其实应该丢到module层，放这里不好（）
>
> ├─gimbal/								#云台控制代码
>
> │　├─...										#xxx_interface及xxx
>
> ├─test/									#调试用任务，可以通过`#define ROBOT_TEST`来屏蔽其他任务运行
>
> ├─UI/										# UI控制代码
>
> │　├─UI_interface.c				#UI接口层，包括自动刷新和修改检测以及UI实例的定义等。
>
> │　├─UI_interface.h
>
> │　├─UI_ref.h							#关于裁判系统UI部分的一些宏定义
>
> │　├─UI_user_defined.h			#写的一个小玩具，操作手可以通过按键直接修改UI和保存到片上flash
>
> ​															~~#有空的话实现下玩贪吃蛇，这样翻车了也不无聊（X~~
>
> │　├─UI.c								#UI控制主逻辑
>
> │　└─UI.h
>
> ├─robot_def.h						#定义机器人相关参数，详情参考跃鹿框架
>
> ├─robot_task.h						#功能类似freertos.c，方便管理任务
>
> ├─robot.c								 #承担进入rtos前的初始化工作
>
> └─robot.h

**（摘自技术开源报告）：**

> 1. app层间各应用无法直接通信，需要通过module层中的消息中转`message_center模块`进行发布/订阅数据，以此来避免潜在的内存错误。
>
> 2. app层中，通过`robot_cmd任务`结合控制数据和各app的状态信息进行决策，设置各app的工作状态并传输必要参数。这种方式可以在调试时快速定位导致异常的状态。
>
> 3. 臂和推杆的自动模式都使用状态机。考虑到场地误差，将臂自动模式数据（关键帧关节角度值等）以固定格式存入片上flash。调试时，可以通过遥控器开启`拖动示教功能`，以臂当前位置为起点，自动记录其一段时间内的移动轨迹，期间可通过遥控器设置关键帧的动作（暂停、开关气泵、延时等）。待记录结束后可用遥控器操控机械臂展示新记录的动作，选择丢弃或覆盖某一自动模式。
>    由此，我们可以在适应性训练期间，以几分钟为代价，快速制作出一份可以稳定取出官方场地内矿石的自动模式。后期还可以通过微调参数加快取矿速度。
>
> 4. 原框架内的UI部分需手动触发更新，存在丢包风险和延迟问题。为改善该情况并使修改UI变成轻松的事，将每个UI定义为一个单独的实例。
>
>    代码内定义了一个函数可以将UI实例的参数与上一次发送的数据比较，如果不同，则置位`发送标志位`，并可以设置优先级、重发频率等。
>
>    `UI_Task`任务会定时执行，扫描所有的UI实例，将受到修改的UI实例填入发送区，以此实现自动同步更新，同时使修改UI内容变得轻松:
>
>    ```c
>    // 如修改整数UI的值，只需要一句话
>            number_pump_air_arm->param.Number.value = UI_data_recv.pump_air_arm;
>    // 如想根据某个值来呈现不同的颜色，只需一句话
>    	//例1
>    	UI_ColorSwitchDetect_Char(string_armAutoMode_, 2, UI_data_recv.arm_selected_mode_state, Graphic_Color_Orange, Graphic_Color_Cyan);
>    	//例2	
>    	UI_StateSwitchDetect_Graph(circle_armAutoMode, 3, UI_data_recv.arm_mode, Graphic_Color_White, Graphic_Color_Green, Graphic_Color_Yellow);
>    ```
>
> 测试方法
>
> 1. 代码中将每一个设备定义为一个`实例`，每个实例均配备了相应的`看门狗`，喂狗操作在每次从设备中接受数据的同时进行。一般，看门狗的触发函数中包含发送错误信息和错误处理的操作。
>    由此，当任一模块发生错误时，我们都可以接受到错误讯息，并快速定位错误与修复。
>    此外我们可以在调试模式内写一些循环动作，让电机不断地运动(或底盘持续小陀螺)，通过观察有无错误日志的产生来判断整车工作是否稳定。
> 2. 在临上场前，需要快速将所有自动模式过一遍~~以增加信心~~。但工程机器人存在14种不同的自动模式，如抛掉整活用模式，为充分发挥该机器人的特性，在极限压缩下也有10种自动模式，而一般思路（一个组合键对应一个动作）对遥控器不太合适。
>    由此，我们给予每种自动模式一个id号，通过遥控器拨杆进行id号的切换和选择（通过板载LED灯颜色确认模式或心里默数），解决了遥控器按键不足的问题。

**优化方向：**

或许只有`application\UI\UI_interface.c`和`application\arm\auto_mode_.h`有可参考的点

这部分代码称不上完善，UI部分暂无完美的防字符串丢包的思路（字符串只能单包发送，无法和图形UI一样插空发送，如采取一样的思路，会占用发送资源），代码中虽留了刷新的接口，但我将刷新频率设为了0，导致场上字符串丢失了orz

机械臂的自动模式需要在关键帧的记录再进行优化，同时轨迹跟随的时候应通过算法来`优化机械臂的末端摆动放大效应`，获取更高的` 精度`，同时让`拖动示教`功能更加实用。（目前的拖动示教通过设定关键帧之间一个较大的延迟来确保轨迹跟随时的精度，这会使机械臂的运动非常不丝滑)

**注意事项**

1.本开源仅限于RoboMaster参赛队之间队内交流使用，不得用于任何商用行为，开源者保留采取一切法律措施的权利；

2.开源目的在于加强参赛队之间交流，有助于提高自身和其他参赛队的水平；

3.本开源的最终解释权归南京理工大学Alliance战队所有。

**通讯信息：**

> qq:1373987167
